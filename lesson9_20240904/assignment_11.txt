
1. 간선에 방향이 없고, 임의의 노드가 루트인 트리라면 특정 노드를 루트로 서브트리에서 일부 부모-자식 관계가 역전될 수 있다. (O)
    => 간선에 방향과 가중치가 존재하지 않으니 자유롭게ㅐ 서브트리 구성이 가능
    => 이러한 서브트리에는 이전에는 부모였으나, 다른 서브트리에서는 자식으로 노드가 편성될 수 있다.

2. 쿼리의 답이 되는 서브트리의 크기는 해당 서브트리의 루트 노드를 포함므로 항상 1 이상이다. (O)
    => 주어지는 쿼리의 정점이 정점에 포함되지 않는경우 0이 되겠지만, N 이로 주어지기에 항상 존재하는 정점으로 봐야한다.
    => 주어진 정점이 최하위 노드여도 본인노드가 포함되기에 답은 항상 1 이상이다.

3. Q개의 모든 쿼리에 대해 크기가 n인 트리를 모두 순회하는 방법은 N, Q의 최대값인 100,000 이므로 O(N * Q) 의 시간복잡도로 풀 수 없다. (O)
    => 쿼리에 담긴 정점의 연결정보만 보면 되기에, 모든 트리를 순환할 필요는 없다.
    => 만약 쿼리의 정점을 항상 일일이 트리를 탐색하여 접근한다면 O(N * Q) 의 복잡도가 뜰것이며, 이는 최대치일때 풀이가 불가능할 것이다.
    => 대략 100억 건의 데이터 처리가 필요..

4. A,B,C 노드를 자식으로 가진 부모노드 P를 루트로 하는 서브트리에 포함된 정점의 수는 (A,B,C노드를 루트로 하는 서브트리에 속한 정점의 개수를 모두 던한 값 +1) 이다. (O)
    => 부모노드와 A,B,C 노드의 서브트리 노드 개수를 더한면 P 노드를 기반으로 한 서브트리의 정점갯수가 도출될 것이다.
