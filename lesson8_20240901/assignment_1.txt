
1. 한번에 담아야하는 데이터의 최대 크기를 모를때, Queue 와 List 모두 동적자료로 활용 가능하다. (0)
    => Queue 와 List 모두 단순 new 명령어로만 생성이 가능
    => 이는 new 명령어와 함께 크기를 선언해야하는 배열과 차이를 보임

2. Queue 는 List 와 달리 선입선출을 약속하는 자료구조이기에, Queue 만을 위한 특별한 구현체가 필요하다. (0)
    => Queue의 java 구현 시, PriorityQueue 구조체를 활용
    => 이를 보았을떄 Queue를 위한 특별한 구조체가 필요하다고 보여짐

3. List 와 Queue 모두 순차적인 데이터 구조를 가지며, 원하는 순번의 데이터에 접근하고 조작할 수 있다. (X)
    => List 자료형의 경우, where 함수를 통해 원하는 순번의 데이터 접근 및 조작이 가능하다.
    => 그러나 Queue의 경우 add, pop 이라는 선입선출 함수밖에 존재하지 않기에, 원하는 순번에는 접근이 불가능하다.

4. Queue는 대기열, 스케쥴링, 작업처리와 같이 순서대로 처리되는 작업을 관리하는데 유용하다. (0)
    => Queue는 선입선출의 특성을 가지는 자료형이기에 순차적인 작업처리에 유용

5. 1158 요세푸스 문제의 경우 List를 활용하여 문제를 풀 경우, 사람을 제거할때마다 O(N)의 시간 복잡도가 소요되지만, Queue를 활용하면 시간복잡도를 낮출 수 있다. (X)
    => 사람을 제거할때 N의 시간복잡도가 소요된다 함은, 사람을 제거할때마다 사람들로 구성된 원을 재구성함을 의미
    => 그러나 해당 부부은, 입력 K에 따라 제거되는 위치가 달라지기에, 선입선출만 가능한 Queue 만으로 원의 재구성 구현은 어렵다고 보여짐
    => 해당 문제에서 Queue의 활용은 제거된 사람들을 Queue의 넣은 뒤, 접답 도출시 뽑아내는 기능이 최대라고 보여짐
    => 이에 Queue 를 활용해도 시간복잡도 낮추기는 어렵다고 보여짐