
1. front/back 양 끝에 대한 삽입/삭제가 모두 필요하므로 일반적인 Queue 하나만을 사용해서는 풀 수 없다. (X)
    => LinkedList 를 기반한 Queue를 구성하면 하나의 Queue로도 Deque 구성이 가능하다

2. List와 같이 삽입/삭제를 양방향으로 하거나 위치를 지정할 수 있는 자료구조를 사용해 풀 수 있다. (O)
    => 특히 데이터의 삭제와 추가에 유리한 LinkedList 자료형을 활용하여 구성이 가능할것으로 보인다.

3. 가장 앞과 가장 뒤에서만 추가/삭제가 일어나므로 Single Linked List로 구현해도 가장 앞 노드와 가장 뒷 노드를 모두 관리한다면 모든 삽입/삭제를 O(1) 시간복잡도로 처리할 수 없다. (X)
    => LinkedList 의 시간복잡도가 올라가는 주요요인은 중간 노드까지의 탐색시간이다.
    => 그러나 구현하려는 덱의 경우 맨 앞과 뒤에서만 데이터의 관리가 이뤄진다.
    => 즉, 맨 앞과 끝의 노드만 탐색하면 되니, 시간복잡도가 O(1) 이상으로 상승될 가능성은 없다.

4. 중간 원소에 접근하는 연산이 없으므로 Array 기반의 Queue와 같이 front/rear index를 관리하되 연산에 따라 각각 증가/감소하게하면 Array 기반의 Deque도 구현할 수 있다. (O)
    => Array 기반의 Deque 역시, 설명처럼 맨 앞과 맨 뒤의 index만 관리되면 Deque의 구성이 가능하다.
    => 이는, 데이터를 추가하는 경우 이후 데이터를 뒤로 미루는 특성이 있기에 가능하다.
